# B tree

## 정의

균형을 유지하는 다진 탐색 트리의 한 종류로, 데이터베이스, 파일 시스템 등에서 효율적인 탐색, 삽입, 삭제를 위해 사용되는 자료구조이다.

- 균형트리
    - 모든 리프 노드는 항상 같은 깊이에 위치한다.
    - 데이터 삽입/삭제로 인해 트리가 비대칭적으로 커지지 않는다.

```makefile
*트리의 높이*

루트 노드에서 리프 노드까지의 최대 경로 길이를 의미한다. 

: 높이가 낮을 수록 → 연산에 필요한 비교 횟수가 줄어들어 성능이 개선됨
```

M : 각 노드의 최대 자녀 노드 수 (얘를 기준으로 파라미터 설명)(트리의 차수)

M-1 : 각 노드의 최대 key 수

M/2 : 각 노드의 최소 자녀 노드 수(root node, leaf node 제외)

M/2 - 1 : 각 노드의 최소 key 수(root node 제외) 

![스크린샷 2024-11-20 오후 2.33.02.png](/Database/img/database_b_tree.png)

- 이진탐색트리(BST)를 일반화한 트리다.
- 내부 노드의 key수가 x개라면 자녀 노드의 수는 언제나 x+1개다.
- 노드가 최소 하나의 key는 가지기 때문에 몇 차 B tree 인지와 상관없이 내부 노드는 최소 두 개의 자녀는 가진다.
- 노드 내의 key들은 오름차순으로 저장된다.
- 모든 leaft노드들은 같은 레벨에 있다(==tree에서 depth)

```makefile
**용어 정리**

- Root Node : 트리의 최상단에 있는 노드로, 부모가 없는 유일한 노드.
- Leaf Node : 자식 노드가 없는 노드. 즉, 트리의 끝 부분에 위치한 노드들.
- Internal Node(내부 노드) : 리프 노드가 아니고, 최소 하나 이상의 자식 노드를 가진 노드.
```

## B tree 데이터 삽입

- 추가는 항상 leaf노드에 한다.
- 노드가 넘치면 가운데 key를 기준으로 좌우 key들은 분할하고 가운데 key는 승진한다.

![여기서는 데이터 == 키 동일하게 사용, 실제에서는 키를 통해 데이터 접근 함 ](/Database/img/database_b_tree_insert.png)

여기서는 데이터 == 키 동일하게 사용, 실제에서는 키를 통해 데이터 접근 함 

## B tree 데이터 삭제

- 삭제도 항상 leaf 노드에서 발생한다.
- 삭제 후 최소 key 수보다 적어졌다면 재조정한다.
- 몇가지 예시)

![**(3차) 리프노드에서 삭제하고 재조정 할 필요 없는 경우**](/Database/img/database_b_tree_delete_case_1.png)

**(3차) 리프노드에서 삭제하고 재조정 할 필요 없는 경우**

![**(3차) 리프노드에서 삭제하고 재조정 해야하는 경우**](/Database/img/database_b_tree_delete_case_2.png)

**(3차) 리프노드에서 삭제하고 재조정 해야하는 경우**

[B-트리(B-Tree)란? B트리 탐색, 삽입, 삭제 과정](https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC)

---

# B+ tree

## 정의

균형 이진 탐색 트리의 확장판으로, 데이터베이스 및 파일 시스템에서 많이 사용하는 자료구조이다. 

- 키들이 정렬된 상태로 저장되며, 리프 노드에 모든 데이터가 저장되고, 리프 노드 간 연결 리스트로 연결돼 있다.
- 내부 노드는 탐색 경로를 제공하기 위한 인덱스 역할을 한다.

| **특징** | **B 트리** | **B+ 트리** |
| --- | --- | --- |
| **데이터 저장 위치** | 데이터가 **내부 노드와 리프 노드**에 모두 저장됨. | 데이터가 **리프 노드에만 저장**됨. |
| **탐색 효율** | 데이터가 내부 노드에도 저장되므로 추가적인 비교 필요. | 모든 데이터가 리프 노드에 있어 탐색이 일정함. |
| **리프 노드 간 연결** | 리프 노드 간 연결이 없음. | 리프 노드 간 **연결 리스트**로 연결됨. |
| **데이터 범위 검색** | 비효율적(모든 관련 노드 탐색 필요). | 리프 노드를 순차적으로 탐색 가능해 효율적. |
| **삽입/삭제 시 구조 변화** | 삽입/삭제로 내부 노드가 자주 바뀜. | 데이터가 리프 노드에만 있어 내부 노드 변경 빈도가 낮음. |
| **사용 사례** | 파일 시스템, 데이터베이스(단순 트리 구조). | 파일 시스템, 데이터베이스(대규모 데이터 처리). |

![스크린샷 2024-11-20 오후 3.30.52.png](/Database/img/database_b_plus_tree.png)

## B+ tree의 장점

1. 효율적인 범위 검색
    - 리프 노드들이 연결 리스트로 연결되어 있어, 연속적인 데이터를 빠르게 읽을 수 있다.
    - 데이터베이스에서 범위 검색을 최적화하는 데 사용된다.
    - 범위의 시작점만 찾으면 이후는 디스크 I/O 없이 빠르게 연속 데이터 접근 가능.
        
        ![스크린샷 2024-11-20 오후 6.41.11.png](/Database/img/database_b_plus_tree_pros.png)
        

2. 균형 유지
    - 삽입/삭제가 일어나도 항상 트리는 균형 상태를 유지한다.
    - 따라서 탐색, 삽입, 삭제 모두 O(log n)의 시간 복잡도를 가진다.
3. 대규모 데이터 처리
    - 리프 노드에만 데이터를 저장하므로 내부 노드의 크기를 최소화할 수 있다.
    - 이는 트리의 높이를 줄여 디스크 접근 횟수를 최소화한다.

## B+ tree의 단점

1. 높은 구현 복잡도
    - 삽입/삭제 시 노드 분할과 병합이 발생하므로 구현이 다소 복잡하다.

---

# B- tree

이론적 개념에 가까워 실제로는 B or B+ 트리에 비해 덜 사용된다. 

B트리와 거의 유사하다, B 트리의 변형을 언급하기 위해 사용되는 경우가 많다.

# 면접질문
* B 트리와 B+ 트리의 차이점은 무엇인가요? (B 트리와 B+ 트리의 구조적 차이와 각 자료구조의 장단점을 설명해 보세요.)
* B 트리에서 삽입과 삭제 시 노드 분할과 병합이 발생하는 이유는 무엇인가요?(B 트리의 균형을 유지하기 위한 삽입과 삭제 과정에서의 노드 분할과 병합 과정을 설명해 보세요.)
* B+ 트리에서 범위 검색이 효율적인 이유는 무엇인가요?(B+ 트리의 리프 노드 간 연결 구조가 범위 검색에 어떻게 활용되는지 설명해 주세요.)

# 참고자료 

[(1부) B tree의 개념과 특징, 데이터 삽입이 어떻게 동작하는지를 설명합니다! (DB 인덱스과 관련있는 자료 구조)](https://www.youtube.com/watch?v=bqkcoSm_rCs)
[B-트리(B-Tree)란? B트리 탐색, 삽입, 삭제 과정](https://velog.io/@chanyoung1998/B%ED%8A%B8%EB%A6%AC)