# CPU 스케줄링 알고리즘

## CPU 스케줄링 (CPU Scheduling)

![](/OS/img/os_cpu_scheduling.png)

**운영체제**가 **CPU 자원**을 여러 프로세스에 **효율적으로 할당**하기 위한 방법을 정의한다. 

운영체제는 여러 프로세스가 동시에 실행되기 때문에, CPU가 어떤 프로세스를 언제 실행할지 결정하는 것이 중요한 과제이다. 

이를 위해 다양한 CPU 스케줄링 알고리즘이 존재하며, 각각의 알고리즘은 **처리 효율성**, **응답 시간**, **대기 시간** 등의 성능을 최적화하는 방식이 다르다.

## CPU 스케줄링이 필요한 상황

![](/OS/img/os_cpu_scheduling_status.png)

1. **프로세스가 실행 상태에서 대기 상태로 전환될 때**:
    - 예: 프로세스가 **I/O 작업을 요청**하면, CPU를 사용하지 않으므로 **다른 프로세스**에게 CPU를 넘겨야 합니다.
2. **프로세스가 실행 상태에서 준비 상태로 전환될 때**:
    - 예: 선점형 스케줄링에서는 **우선순위가 더 높은 프로세스가 준비 상태로 도착**하면, 현재 실행 중인 프로세스의 실행을 중단하고 더 높은 우선순위의 프로세스에 CPU를 할당합니다.
3. **프로세스가 대기 상태에서 준비 상태로 전환될 때**:
    - 예: **I/O 작업을 마친 프로세스**가 다시 준비 상태가 될 때, CPU를 사용할 수 있는 기회가 생깁니다. 이때, 스케줄러는 어떤 프로세스가 CPU를 할당받을지 결정합니다.
4. **프로세스가 종료될 때**:
    - 예: 프로세스가 작업을 **완료하면 CPU가 비워지기** 때문에, 다음 프로세스를 선택하여 CPU를 할당합니다.

`비선점형`은 `1번과 4번`에서, `선점형`은 `1~4번 모두`에서 스케줄링이 발생한다. 

### 선점형과 비선점형 스케줄링 차이

**선점형 스케줄링**

- 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 있는 방식
- CPU처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영 가능
- 잦은 문맥 교환으로 오버헤드(Overhead)가 커질수 있음

**비선점형 스케줄링**

- 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식
- 필요한 문맥 교환만 일어나므로 오버헤드가 상대적으로 작음
- 프로세스의 배치에 따라 효율성 차이가 많이 남

### 디스패처(Dispatcher)

CPU 스케줄러가 선택한 프로세스를 실행 가능한 상태로 만들어주는 역할을 맡는다. 

- CPU 제어권을 프로세스에 넘겨주는 작업이다.
- Context Switching을 진행하여, CPU의 모드 전환(커널모드 ↔ 유저모드)을 하여 프로세스 실행 준비를 함
    
    **전환 시나리오** 
    
    - 시스템 호출(System Call)
        - 예) 프로그램이 파일을 열기 위해 `open()` 시스템 호출을 할 때, 이 호출은 커널 모드로 전환되어 파일 시스템에 접근하고, 파일을 처리한 후 다시 유저 모드로 돌아온다.
    - 인터럽트(Interrupt)
        - 예) 키보드를 누를 때마다 인터럽트가 발생하여 운영체제가 입력을 처리하는데, 이 과정에서 커널모드로 전환된다.
    - 예외(Exception)
        - 예) 0으로 나누기와 같은 잘못된 연산이 발생했을 때, 커널 모드로 전환되어 예외를 처리하고, 프로그램을 안전하게 종료하거나, 적절한 예외 처리 루틴을 수행한다.

### 디스패처와 스케줄러 차이

- 스케줄러
    - 준비 큐에 있는 프로세스 중 다음에 실행할 프로세스를 결정하는 역할을 한다.
    - 스케줄링 알고리즘을 사용해 프로세스의 우선순위나 도착 시간등을 고려하여 선택한다.
- 디스패처
    - 스케줄러가 선택한 프로세스를 실제로 CPU에서 실행할 수 있도록 돕는 역할을 한다.
    - **스케줄러**가 프로세스를 선택하면, **디스패처**는 해당 프로세스에 **CPU를 할당**하고, **문맥 교환**을 수행하여 프로세스가 실행되도록 준비한다.

### CPU 스케줄링 평가 기준

| **평가 기준** | **설명** | **목표** | **계산 방법** |
| --- | --- | --- | --- |
| **CPU 이용률(CPU Utilization)** | CPU가 사용되는 비율 | CPU의 유휴 시간을 최소화하고 100% 활용을 목표 | (CPU 사용 시간 / 전체 시간) * 100 |
| **처리량(Throughput)** | 단위 시간당 완료된 프로세스의 수 | 가능한 많은 프로세스를 처리 | 완료된 프로세스 수 / 단위 시간 |
| **대기 시간(Waiting Time)** | 프로세스가 대기 큐에서 기다린 총 시간 | 대기 시간을 최소화하여 지연을 줄임 | 모든 대기 시간의 합 |
| **응답 시간(Response Time)** | 프로세스가 처음으로 응답을 받기까지 걸린 시간 | 짧은 응답 시간으로 빠른 응답을 제공 | 첫 번째 CPU 할당 시간 - 프로세스 도착 시간 |
| **반환 시간(Turnaround Time)** | 프로세스가 도착 후 종료될 때까지의 총 시간 | 반환 시간을 최소화하여 프로세스가 빨리 완료되도록 함 | 종료 시간 - 도착 시간 |

## CPU 스케줄링 알고리즘 종류

### 선입 선처리 스케줄링(First Come First Served, FCFS)

처음 도착한 프로세스부터 실행하는 방식이다. 

- 구현이 쉽고 간단하다. (+)
- 비선점형이기 때문에, 긴 작업이 먼저 오면 짧은 작업이 긴 시간 동안 기다려야 하는 Convoy Effect가 발생할 수 있다. (-)

```html
프로세스 도착 순서: P1, P2, P3 (각각 10ms, 5ms, 2ms 소요)
실행 순서: P1 → P2 → P3
```

### 최단 작업 우선 스케줄링(Shortest Job First, SJF)

실행 시간이 가장 짧은 프로세스에 우선적으로 CPU를 할당한다. 

- 비선점형과 선점형 방식이 있다.
    - 비선점형 : 현재 실행 중인 프로세스가 끝날 때까지 다른 프로세스가 끼어들지 못한다.
    - 선점형(SRTF) : 더 짧은 작업이 들어오면 현재 작업을 중단하고 짧은 작업을 먼저 실행한다.
- 짧은 작업이 먼저 처리되어 평균 대기 시간이 최소화된다. (+)
- 실행 시간을 미리 정확히 알기 어렵고, 긴 작업이 계속 밀릴 수 있어 **기아 현상(Starvation)**이 발생할 수 있다. (-)

```css
프로세스 도착 시간 및 실행 시간: P1(0ms, 6ms), P2(2ms, 4ms), P3(4ms, 1ms)
실행 순서 (SJF 비선점형): P1 → P2 → P3
실행 순서 (SRTF 선점형) : P1(0ms ~ 4ms, 남은 시간 2ms) -> P3(4ms ~ 5ms) -> P1(5ms ~ 7ms) -> P2

```

자세한 예시 링크 :  https://wonit.tistory.com/104

### 라운드 로빈 스케줄링(Round Robin, RR)

선점형 스케줄링의 일종으로, 각 프로세스에 **동일한 시간 할당량**을 부여하고, 순환적으로 CPU를 할당하는 방식이다. 

- 시간 할당량이 끝나면 다음 프로세스로 CPU가 넘어가며, 만약 프로세스가 끝나지 않았다면 
나중에 다시 기회가 돌아온다.
- 응답시간이 짧고 모든 프로세스가 공평하게 CPU를 할당받는다.(+)
- 시간 할당량이 너무 길면 FCS처럼 동작하고, 너무 짧으면 오버헤드가 커진다.(-)

```css
시간 할당량: 4ms
프로세스 도착 시간 및 실행 시간: P1(0ms, 6ms), P2(1ms, 8ms), P3(2ms, 3ms)
실행 순서: P1(4ms) → P2(4ms) → P3(3ms) → P1(2ms) → P2(4ms)
```

### 우선순위 스케줄링(Priority)

각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 CPU를 할당한다.

- 비선점형과 선점형 방식이 있다.
- 중요한 작업을 먼저 처리할 수 있다.(+)
- 낮은 우선순위의 작업이 계속 밀리면 Starvation이 발생할 수 있다. 이를 해결하기 위해 Aging(오래 기다린 프로세스의 우선순위를 점차 높여줌) 기법이 사용된다.

```css
프로세스 우선순위: P1(우선순위 3), P2(우선순위 1), P3(우선순위 2)
실행 순서: P2 → P3 → P1 (우선순위가 낮을수록 먼저 실행)
```

### 다단계 큐 스케줄링(MultiLevel Queue)

프로세스를 우선순위에 따라 여러 개의 큐로 나누고, 각 큐는 서로다른 스케줄링 알고리즘을 사용한다. 

선점형과 비선점형 모두 가능하다.

예) 인터렉티브 작업(사용자 입력 작업)과 배치 작업(백그라운드 처리 작업)을 각각 다른 큐에 넣고, 인터렉티브 작업은 **라운드 로빈**, 배치 작업은 **FCFS**를 사용하는 방식이다. 

❗️병렬적으로 동시에 처리하는 것이 아니라, 우선순위에 따라 순차적으로 처리하는 것이다.

![](/OS/img/os_multilevel_queue.png)

- 다양한 프로세스의 특성에 맞춰 스케줄링이 가능하다. (+)
- 큐 간의 우선순위를 정할 때 불공평한 처리가 발생할 수 있다 (-)

### 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue)

프로세스가 서로 다른 큐 간에 이동할 수 있도록 허용하는 스케줄링 방식이다. 이는 프로세스의 우선순위를 동적으로 조정하고, 실행 시간이나 대기 시간에 따라 큐를 변경하여 공정성과 효율성을 높이는 방법이다. 

선점형으로 동작한다. 

![Burst Time = 프로세스가 완료되기 위해 CPU에서 실행되어야 하는 총 시간이다. 
Quantum = 프로세스가 라운드 로빈 방식으로 CPU를 사용할 수 있는 최대 시간이다.](/OS/img/os_multilevel_feedback_queue.png)

Burst Time = 프로세스가 완료되기 위해 CPU에서 실행되어야 하는 총 시간이다. 
Quantum = 프로세스가 라운드 로빈 방식으로 CPU를 사용할 수 있는 최대 시간이다.

- 우선순위가 높은 큐는 일반적으로 **짧은 시간 할당량(퀀텀)**을 가지고, 우선순위가 낮은 큐는 더 긴 시간 할당량을 갖거나 FCFS방식으로 처리된다.
- 짧은 작업에 대한 빠른 응답을 할 수 있다. (+)
- 긴 실행 시간을 가진 프로세스는 시간 할당량을 초과하여 하위 큐로 내려가며 효율적으로 처리할 수 있다. (+)
- 큐 이동 규칙의 복잡성이 있다. 프로세스가 어떤 규칙에 따라 큐 간에 이동할지 설정하는 것이 복잡할 수 있다.(-)

## 예상 면접 질문

- 선점 스케줄링과 비선점 스케줄링의 차이점과 각각의 예시 1개씩 설명해주세요.
- CPU 스케줄링은 언제 발생하나요? 그리고 그 목적은 무엇인가요?
- CPU 스케줄링의 종류에 대해 알려주세요.

## 참고 자료

- [[운영체제] CPU 스케줄링 알고리즘 정리 및 요약 | FCFS, SJF, Round Robin](https://code-lab1.tistory.com/45)
- [[Operating System - Chapter 5] CPU 스케줄링](https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html)